<!DOCTYPE html>
<html>
<header></header>
<body>

<div id="demo">nothing</div>
<div id="mapholder"></div>

<div class="main">
  <h2>Device Motion</h2>
  <table>
    <tr>
      <td>Event Supported</td>
      <td id="dmEvent"></td>
    </tr>
    <tr>
      <td>acceleration</td>
      <td id="moAccel"></td>
    </tr>
    <tr>
      <td>accelerationIncludingGravity</td>
      <td id="moAccelGrav"></td>
    </tr>
    <tr>
      <td>rotationRate</td>
      <td id="moRotation"></td>
    </tr>
    <tr>
      <td>interval</td>
      <td id="moInterval"></td>
    </tr>
  </table>
</div>

<script type="text/javascript">
//http://w3c.github.io/deviceorientation/spec-source-orientation.html
//https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#examples-synthesis

// there is also speach recognition ... not sure it works


// zmq - node.js -> pub/sub

    var u = new SpeechSynthesisUtterance();
    function speak(txt){
        // var u = new SpeechSynthesisUtterance();
        u.text = txt;
        u.lang = 'en-UK';
        u.rate = 1.2;
        // u.onend = function(event) { alert('Finished in ' + event.elapsedTime + ' seconds.'); }
        speechSynthesis.speak(u);
    }

    // var u = new SpeechSynthesisUtterance();
    // u.text = 'Hello World';
    // u.lang = 'en-UK';
    // u.rate = 1.2;
    // u.onend = function(event) { alert('Finished in ' + event.elapsedTime + ' seconds.'); }
    // speechSynthesis.speak(u);
    speak('Hello');

   if (window.DeviceOrientationEvent) {
    //  console.log("DeviceOrientation is supported");
    //  u.text = 'orientation is supported';
     speak('orientation is supported');
    //  speechSynthesis.speak(u);
    }
    else {
        // console.log('orientation is NOT supported');
        // u.text = 'orientation is NOT supported';
        // speechSynthesis.speak(u);
        speak('orientation is NOT supported');
    }

    if (window.DeviceMotionEvent) {
      window.addEventListener('devicemotion', deviceMotionHandler, false);
    } else {
      document.getElementById("dmEvent").innerHTML = "Not supported."
    }
    // u.text = 'I am done';
    // speechSynthesis.speak(u);
    function deviceMotionHandler(eventData) {
  var info, xyz = "[X, Y, Z]";

  // Grab the acceleration from the results
  var acceleration = eventData.acceleration;
  info = xyz.replace("X", acceleration.x);
  info = info.replace("Y", acceleration.y);
  info = info.replace("Z", acceleration.z);
  document.getElementById("moAccel").innerHTML = info;

  // Grab the acceleration including gravity from the results
  acceleration = eventData.accelerationIncludingGravity;
  info = xyz.replace("X", acceleration.x);
  info = info.replace("Y", acceleration.y);
  info = info.replace("Z", acceleration.z);
  document.getElementById("moAccelGrav").innerHTML = info;

  // Grab the rotation rate from the results
  var rotation = eventData.rotationRate;
  info = xyz.replace("X", rotation.alpha);
  info = info.replace("Y", rotation.beta);
  info = info.replace("Z", rotation.gamma);
  document.getElementById("moRotation").innerHTML = info;

  // // Grab the refresh interval from the results
  info = eventData.interval;
  document.getElementById("moInterval").innerHTML = info;
}

var x = document.getElementById("demo");
function getLocation() {
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(showPosition);
    } else {
        x.innerHTML = "Geolocation is not supported by this browser.";
    }
}
function showPosition(position) {
    x.innerHTML = "Latitude: " + position.coords.latitude +
    "<br>Longitude: " + position.coords.longitude;
}

showPositionMap("20,105");

// Static map from google
function showPositionMap(position) {
    // var latlon = position.coords.latitude + "," + position.coords.longitude;
    var latlon = position;

    var img_url = "http://maps.googleapis.com/maps/api/staticmap?center="+latlon+"&zoom=4&size=400x300&sensor=false";

    document.getElementById("mapholder").innerHTML = "<img src='"+img_url+"'>";
}

// get compass heading
var degtorad = Math.PI / 180; // Degree-to-Radian conversion

function compassHeading( alpha, beta, gamma ) {

  var _x = beta  ? beta  * degtorad : 0; // beta value
  var _y = gamma ? gamma * degtorad : 0; // gamma value
  var _z = alpha ? alpha * degtorad : 0; // alpha value

  var cX = Math.cos( _x );
  var cY = Math.cos( _y );
  var cZ = Math.cos( _z );
  var sX = Math.sin( _x );
  var sY = Math.sin( _y );
  var sZ = Math.sin( _z );

  // Calculate Vx and Vy components
  var Vx = - cZ * sY - sZ * sX * cY;
  var Vy = - sZ * sY + cZ * sX * cY;

  // Calculate compass heading
  var compassHeading = Math.atan( Vx / Vy );

  // Convert compass heading to use whole unit circle
  if( Vy < 0 ) {
    compassHeading += Math.PI;
  } else if( Vx < 0 ) {
    compassHeading += 2 * Math.PI;
  }

  return compassHeading * ( 180 / Math.PI ); // Compass Heading (in degrees)

}


</script>

</body>
</html>
